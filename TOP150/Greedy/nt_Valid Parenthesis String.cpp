
class Solution {
public:
    bool checkValidString(string s) {
        // time: O(n), space: O(1)
        int leftMin = 0, leftMax = 0;
        for (char c : s) {
            if (c == '(') {
                leftMin++; leftMax++;
            } else if (c == ')') {
                leftMin--; leftMax--;
            } else {
                leftMin--; leftMax++;
            }
            if (leftMax < 0) return false; // 即便把所有的 '*' 都当 '(' 用，也抵消不了那么多右括号
            if (leftMin < 0) leftMin = 0; // 代表可以用 '*' 来当做 ( 来抵消 )
        }
        return leftMin == 0; // 剩余 '(' 并且无法用 '*' 来抵消
    }
};

// 使用贪心的思想，可以将空间复杂度降到 O(1)。
// 从左到右遍历字符串，遍历过程中，未匹配的左括号数量可能会出现如下变化：

// 如果遇到左括号，则未匹配的左括号数量加 1；
// 如果遇到右括号，则需要有一个左括号和右括号匹配，因此未匹配的左括号数量减 1；
// 如果遇到星号，由于星号可以看成左括号、右括号或空字符串，因此未匹配的左括号数量可能加 1、减 1 或不变。

// 基于上述结论，可以在遍历过程中维护未匹配的左括号数量可能的最小值和最大值，根据遍历到的字符更新最小值和最大值：

// 如果遇到左括号，则将最小值和最大值分别加 1；
// 如果遇到右括号，则将最小值和最大值分别减 1；
// 如果遇到星号，则将最小值减 1，将最大值加 1。

// 任何情况下，未匹配的左括号数量必须非负，因此当最大值变成负数时，说明没有左括号可以和右括号匹配，返回 false。
// 当最小值为 0 时，不应将最小值继续减少，以确保最小值非负。
// 遍历结束时，所有的左括号都应和右括号匹配，因此只有当最小值为 0 时，字符串 s 才是有效的括号字符串。

// leftMin就是未匹配左括号的最小值
// leftMax就是未匹配左括号的最大值