// 如果按照传统思路：有 k 个鸡蛋、n 层楼，最少需要多少次才能确定临界楼层？
// 那么时间复杂度将是 O(k * n ^ 2)，空间复杂度是 O(n)
// 即使优化后也是 O(k * n * logn)
// 所以尝试使用 给定 k 个鸡蛋 和 最多 m 次操作机会，最大能够测试多少层楼
// dp[m][k] = 能测的最多楼层数
// 假设我有 k 个蛋、能扔 m 次：
// 我先从某一层扔一次，
// 如果碎 → 剩下 (k-1, m-1) 能测的楼层范围；
// 如果没碎 → 剩下 (k, m-1) 能测的楼层范围；
// 再加上这一层自己。

// 状态转移方程：dp[m][k] = dp[m-1][k-1] + dp[m-1][k] + 1
// 其中 dp[m-1][k-1] 是鸡蛋碎了的情况，dp[m-1][k] 是鸡蛋没碎的情况，+1 是当前扔的这一层
// 所以最后只需要查找满足 dp[m][k] >= n 的最小 m 即可（n 是楼层数）
class Solution {
public:
    int superEggDrop(int k, int n) {
        // i 代表操作次数，j 代表鸡蛋数量
        vector<vector<int>> dp(n + 1, vector<int>(k + 1));
        for(int i = 1; ; ++i){
            for(int j = 1; j <= k; ++j){
                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] + 1;
            }
            if(dp[i][k] >= n){
                return i;
            }
        }
    }
};